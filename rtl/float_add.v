//******************************************
//       Floating Point Add Unit
//******************************************

//the floating point add unit performs addition or subtraction of 64-bit
// operands in floating point format. The unit executes instructions 062,
// 063, and 170 through 173. Functional unit time is 6 clock periods.
// A result is normalized even if the operands are unnormalized.
// Out-of-range exponents are detected as described under "floating point
//Arithmetic"

//{Sign[0],exponent[1:15],coefficient[16:63]}
//                        ^binary point

//The exponent portion of the floating point format is represented as a
//biased integer in bits 1 through 15. The bias that is added to the 
//exponents is 40000 (base 8). The positive range of exponents is 40000 through
//57777 (base 8). The negative range of exponents is 37777 through 20000. Thus,
//the unbiased range of exponents is thefollowing:
//              2^-20000 (b8) - 2^+17777 (b8)

//In terms of decimal value, the floating point format of the CRAY-1 allows
//the expression of numbers accurate to about 15 decimal digits in the 
//approximate decimal range of 10^-2500 through 10^+2500

//a zero value or an underflow result is not biased and is represented as a 
//word of all zeros.

//A negative zero is not generated by any functional unit.

//A floating point add range error condition is 
//generated for scalar operands when the larger incoming exponent is 
//greater than or equal to 60000 (b8). The floating point error flag is
//set and an exponenet of 60000 (b8) is sent to the result register along with the 
//computed coefficient, as in the following example:
//
//              60000.4  (Range Error)
//            + 57777.4
//             ---------
//              60000.6 (Result Register)



//Floating point addition or subtraction is performed in a 49-bit register.
//Trial subtraction of the exponents occurs to select the operand to be shifted
//down for aligning the operands. The larger exponent operand carries the sign
//and the shift is always to the right. Bits shifted out of the register are 
//lost; no round-up takes place.

//--------------------------------------------------------------------------------
// 062ijk Floating sum of (Sj) and (Sk) to Si
// 063ijk Floating difference of (Sj and (Sk) to Si

//these instructions are performed by the floating point add unit.
// Operands are assumed to be in floating point format. The result is
//normalized even if the operands are unnormalized. Underflow and
//overflow conditions are described above. 

//The 062 instruction forms the sum of the floating point quantities
//in Sj and Sk and enters the normalized result into Si.
//The 063 instruction forms the difference of the floating point
//quantities in Sj and Sk and enters the normalized result into Si.

//execution time = 6 CPs

//special cases:
//062: (Si) = (Sk) normalized if j = 0 and k != 0
//     (Si) = (Sj) normalized if (Sj) exponent is valid, j != 0 and k = 0
//063: (Si) = -(Sk) normalized if j = 0 and k != 0 
//     (Si) = (Sj) normalized if (Sj) exponent is valid, j != 0 and k = 0

//arithmetic error allows 0 to 9 CPs + 2 parcels to issue before 
//interrupt occurs if f.p error flag is set.

module float_add(clk, rst, i_cip, i_vstart,i_vector_length, i_sj, i_sk,i_v0,i_v1,i_v2,i_v3,i_v4,i_v5,i_v6,i_v7, o_busy, o_result, err);
    input wire        clk;
	 input wire        rst;
	 input wire [15:0] i_cip;
	 input wire        i_vstart;
	 input wire [6:0]  i_vector_length;
    input wire [63:0] i_sj;
    input wire [63:0] i_sk;
	 input wire [63:0] i_v0;
	 input wire [63:0] i_v1;
	 input wire [63:0] i_v2;
	 input wire [63:0] i_v3;
	 input wire [63:0] i_v4;
	 input wire [63:0] i_v5;
	 input wire [63:0] i_v6;
	 input wire [63:0] i_v7;
    output reg [63:0] o_result;
	 output wire       o_busy;
    output wire err;

    wire [6:0] instr;
	 wire [2:0] cip_j,cip_k;
	 reg [2:0]  cur_j, cur_k;   //select the right vector registers
	 reg [6:0]  reservation_time;
	 reg  [63:0] v_k_src;
	 reg  [63:0] v_j_src;
	 wire [63:0] selected_j_src;
	 wire [63:0] selected_k_src;
    reg sj_sign0, sk_sign0;
    reg sj_sign1, sk_sign1;
    reg sj_sign2, sk_sign2;
    reg result_sign3, result_sign4;
    reg [14:0] sj_exp0, sk_exp0;
    reg [14:0] sj_exp1, sk_exp1;
    reg [14:0] result_exp2, result_exp3, result_exp4;
    reg [47:0] sj_coef0, sk_coef0;
    reg [47:0] sj_coef1, sk_coef1;
    reg [47:0] sj_coef2, sk_coef2;
    reg [48:0] pre_norm_result3;
    reg [48:0] pre_norm_result4;
    wire jgtk0, jeqk0;
    reg  c_jgtk2;                  //test if j exp is greater than k exp (and for coefficients)
    reg  c_jeqk2;                  //test if j exp equals k exp   (and for coefficients)
    reg [14:0] exp_sj_minus_sk0;
    reg [14:0] exp_sk_minus_sj0;

    reg [6:0] instr0, instr1, instr2;
    wire [6:0] lz_result;
    reg [6:0] lz_result4;
    wire shift_j1;
    wire shift_k1;
    wire exp_diff_too_big;      //detects if exponent shift is greater than 48 bits

    wire [47:0] pre_norm_result_carry;
    wire [48:0] norm_coef;
    wire [14:0] norm_exp;

    wire add;                   //determine if you should add or subtract

//0. Subtract exponents to determine which to shift.
//1. Shift smallest one to the right by the difference
//2. figure out which has largest magnitude
//3. Add/subtract mantissas
//4. leading zero count
//5. re-normalize result

assign instr = i_cip[15:9];
assign cip_j = i_cip[5:3];
assign cip_k = i_cip[2:0];

always@(posedge clk)
   if(i_vstart)
	   begin
		   cur_j <= cip_j;
			cur_k <= cip_k;
		end

//select the correct vector sources
always@*
   begin
	   case(cur_j)
		   3'o0:v_j_src = i_v0;
			3'o1:v_j_src = i_v1;
			3'o2:v_j_src = i_v2;
			3'o3:v_j_src = i_v3;
			3'o4:v_j_src = i_v4;
			3'o5:v_j_src = i_v5;
			3'o6:v_j_src = i_v6;
			3'o7:v_j_src = i_v7;
		endcase
	end
	
always@*
   begin
	   case(cur_k)
		   3'o0:v_k_src = i_v0;
			3'o1:v_k_src = i_v1;
			3'o2:v_k_src = i_v2;
			3'o3:v_k_src = i_v3;
			3'o4:v_k_src = i_v4;
			3'o5:v_k_src = i_v5;
			3'o6:v_k_src = i_v6;
			3'o7:v_k_src = i_v7;
		endcase
	end

//now switch between the vector and scalar sources
assign selected_j_src = (reservation_time==7'b0) ? i_sj : v_j_src;
assign selected_k_src = (reservation_time==7'b0) ? i_sk : v_k_src;

//and now manage the FU reservation for a vector instruction
always@(posedge clk)
   if(rst)
	    reservation_time <= 7'b0;
	else if(i_vstart)
	    reservation_time <= i_vector_length + 7'b0000100;   //functional unit reservation for VL + 4
	else if(reservation_time!=7'b0)
	    reservation_time <= reservation_time - 7'b1;

assign o_busy = (reservation_time != 7'b0);


always@(posedge clk)
   o_result <= {result_sign4, (result_exp4[14:0] + ~{8'b0,lz_result4[6:0]} + 15'b1), (pre_norm_result4[47:0] << lz_result4[6:0])};

float_add_lz lz(.sj(pre_norm_result_carry[47:0]), .lz_final_result(lz_result[6:0]));

    assign shift_j1 = (~jgtk0 & ~jeqk0);                //if j < k, shift j to the right
    assign shift_k1 = jgtk0;                            //if j > k, shift k to the rigth

    assign exp_diff_too_big = (shift_j1 & (exp_sk_minus_sj0 > 15'b110000)) | (shift_k1 & (exp_sj_minus_sk0 > 15'b110000));      //determine if shift is greater than 48 bits

    assign add = (instr1[6:0]==7'b0110010);

    assign pre_norm_result_carry[47:0] = pre_norm_result3[48] ? pre_norm_result3[48:1] : pre_norm_result3[47:0];

assign jgtk0 = (sj_exp0 > sk_exp0);              //if exp_sj is greater than exp_sk
assign jeqk0 = (sj_exp0 == sk_exp0);             //if exp_sj equals exp_sk


always@(posedge clk)
   begin
//stage 0 - latch in values and subtract
      sj_sign0 <= selected_j_src[63];
      sk_sign0 <= selected_k_src[63];
      sj_exp0[14:0]  <= selected_j_src[62:48];
      sk_exp0[14:0]  <= selected_k_src[62:48];
      sj_coef0[47:0] <= selected_j_src[47:0];
      sk_coef0[47:0] <= selected_k_src[47:0];
      exp_sj_minus_sk0 <= (selected_j_src[62:48] + ~selected_k_src[62:48] + 15'b1);     //difference of exponents (exp_sj - exp_sk)
      exp_sk_minus_sj0 <= (selected_k_src[62:48] + ~selected_j_src[62:48] + 15'b1);     //difference of exponenets (exp_sk - exp_sj)
      instr0[6:0] <= instr[6:0];
//stage 1 - shift appropriate value
      sj_exp1[14:0] <= shift_j1 ? (sj_exp0[14:0] + exp_sk_minus_sj0[14:0]) : sj_exp0[14:0];     //calculate new exponent
      sk_exp1[14:0] <= shift_k1 ? (sk_exp0[14:0] + exp_sj_minus_sk0[14:0]) : sk_exp0[14:0];     //calculate new exponent

      sj_coef1[47:0] <= shift_j1 ? (sj_coef0[47:0] >> exp_sk_minus_sj0[5:0]) : sj_coef0[47:0];  //shift coefficient if necessary
      sk_coef1[47:0] <= shift_k1 ? (sk_coef0[47:0] >> exp_sj_minus_sk0[5:0]) : sj_coef0[47:0];  //shift coefficient if necessary

      sj_sign1 <= sj_sign0;     //just copy over previous signs
      sk_sign1 <= sk_sign0;

      instr1[6:0] <= instr0[6:0];

//stage 2 - figure out which has larger magnitude
      result_exp2 <= sj_exp1[14:0];             //both exponents should be equal at this point, so it shouldn't matter which one you grab
      c_jgtk2 <= (sj_coef1[47:0] > sk_coef1[47:0]);             //compare coefficients to figure out which is bigger
      c_jeqk2 <= (sj_coef1[47:0] == sk_coef1[47:0]);
      instr2[6:0] <= instr1[6:0];
      sj_coef2[47:0] <= sj_coef1[47:0];
      sk_coef2[47:0] <= sk_coef2[47:0];
      sj_sign2 <= sj_sign1;    //just copy over previous signs
      sk_sign2 <= sk_sign1;


//stage 3 - add/subtract coefficients
      
      result_exp3 <= result_exp2;
      case({add,(c_jgtk2 | c_jeqk2),sj_sign2, sk_sign2})            //sign=1 if neg
         4'b0000: begin
                    pre_norm_result3[48:0] <= sk_coef2[47:0] + ~sj_coef2[47:0] + 48'b1;              
                    result_sign3 <= 1'b1;        //neg
                  end
         4'b0001: begin
                    pre_norm_result3[48:0] <= sj_coef2[47:0] + sk_coef2[47:0];         
                    result_sign3 <= 1'b0;        //pos
                  end
         4'b0010: begin
                    pre_norm_result3[48:0] <= sj_coef2[47:0] + sk_coef2[47:0];       
                    result_sign3 <= 1'b1;
                  end
         4'b0011: begin
                    pre_norm_result3[48:0] <= sk_coef2[47:0] + ~sj_coef2[47:0] + 48'b1;       
                    result_sign3 <= 1'b0;
                  end
         4'b0100: begin
                    pre_norm_result3[48:0] <= sj_coef2[47:0] + ~sk_coef2[47:0] + 48'b1;     
                    result_sign3 <= 1'b0;
                  end
         4'b0101: begin
                    pre_norm_result3[48:0] <= sj_coef2[47:0] + sk_coef2[47:0];
                    result_sign3 <= 1'b0;
                  end
         4'b0110: begin
                    pre_norm_result3[48:0] <= sj_coef2[47:0] + sk_coef2[47:0];        
                    result_sign3 <= 1'b1;
                  end
         4'b0111: begin
                    pre_norm_result3[48:0] <= sj_coef2[47:0] + ~sk_coef2[47:0] + 48'b1;        
                    result_sign3 <= 1'b1;
                  end
         4'b1000: begin
                    pre_norm_result3[48:0] <= sj_coef2[47:0] + sk_coef2[47:0];
                    result_sign3 <= 1'b0;
                  end
         4'b1001: begin
                    pre_norm_result3[48:0] <= sk_coef2[47:0] + ~sj_coef2[47:0] + 48'b1;
                    result_sign3 <= 1'b1;
                  end
         4'b1010: begin
                    pre_norm_result3[48:0] <= sk_coef2[47:0] + ~sj_coef2[47:0] + 48'b1;
                    result_sign3 <= 1'b0;
                  end
         4'b1011: begin
                    pre_norm_result3[48:0] <= sj_coef2[47:0] + sk_coef2[47:0];
                    result_sign3 <= 1'b1;
                  end
         4'b1100: begin
                    pre_norm_result3[48:0] <= sj_coef2[47:0] + sk_coef2[47:0];
                    result_sign3 <= 1'b0;
                  end
         4'b1101: begin
                    pre_norm_result3[48:0] <= sj_coef2[47:0] + ~sk_coef2[47:0] + 48'b1;
                    result_sign3 <= 1'b0;
                  end
         4'b1110: begin
                    pre_norm_result3[48:0] <= sj_coef2[47:0] + ~sk_coef2[47:0] + 48'b1;
                    result_sign3 <= 1'b1;
                  end
         4'b1111: begin
                    pre_norm_result3[48:0] <= sj_coef2[47:0] + sk_coef2[47:0];
                    result_sign3 <= 1'b1;
                  end
      endcase      
    

//stage 4 - shift by 1 if carry-out==1, then leading zero count
        pre_norm_result4[47:0] <= pre_norm_result_carry[47:0];
        lz_result4[6:0] <= lz_result;
        result_sign4 <= result_sign3;
        result_exp4[14:0] <= pre_norm_result3[48] ? (result_exp3[14:0] + 15'b1) : result_exp3[14:0];
         
   end    





endmodule
